#!/usr/bin/env bash

################################################################################
#
# turf
# ====
#
# Tag your folder. Only available for Bash users.
#
# Notice:
#   1. Copy `_turf' to `turf' before using this script, `_turf' is prototype,
#      and `turf' is for creating private data.
#   2. Don't manually edit this script. Please create issues.
#
# @author AnqurVanillapy
# @date 17 March 2017
# @version 0.1.0
################################################################################

if [[ -e "turf" ]]; then
    turfpath="./turf"       # we are in the repo
else
    turfpath=$(which turf)  # turf is already in $PATH or alias
fi

initloc=171 # lines of code when there are no tags
loc=$(wc -l < $turfpath)
tags_count=$((loc - initloc))

function show_header () {
    echo "turf: Tag your folder"
    echo
}

function show_usage () {
    echo "Usage:"
    echo "  turf"
    echo "  turf {-h|--help}"
    echo "  . turf TAG"
    echo "  turf ls"
    echo "  turf rm TAG"
    echo "  turf add TAG PATH"
    echo
    echo "Note:"
    echo "  Type \`. turf TAG' to change current working directory, because the"
    echo "  script should be sourced to do it."
    echo
    echo "Commands:"
    echo "  add         Add a new folder tag"
    echo "  rm          Remove a new folder tag"
    echo "  ls          List all folder tags and their paths"
    echo
    echo "Warning: Using alphanumeric characters and common punctuation marks"
    echo "with no whitespaces in the folder tags is safer. Signs like '#', '['"
    echo "added to new folder tags may cause some printing flaws, or even fatal"
    echo "errors."
}

function ls_tags() {
    # If no tags, no need to echo.
    if [[ "$tags_count" = "0" ]]; then return; fi

    raw_tags=$(tail -n $tags_count $turfpath)
    for i in `seq $tags_count`; do
        tags=$(echo "$raw_tags" | sed "s=# ==")
    done
    echo "$tags"
}

# Tag name taken, and the serial number nth (or path optionally) returned.
function get_tag() {
    local _tag="$1"
    local tag_nth=0
    all_tags=$(ls_tags)
    is_tag=true # fake boolean type, actually a string
    is_ret_path=false

    # Tag searching by toggling is_tag.
    for item in $all_tags; do
        if [[ "$is_tag" = true ]]; then
            ((tag_nth += 1))

            # Tag found.
            if [[ "$_tag" = "$item" ]]; then
                if [[ "$2" = "-p" ]]; then is_ret_path=true;
                else echo "$tag_nth"; return; fi
            fi
            is_tag=false
        else
            if [[ "$is_ret_path" = true ]]; then echo "$item"; return; fi
            is_tag=true
        fi
    done

    # Tag not found.
    echo "0"
}

function delete_tag() {
    local nth=$1
    nbuf=$(($tags_count - $nth))
    linebuf=$(tail -n $nbuf $turfpath)

    # Delete the nth tag.
    for i in `seq $(($nbuf + 1))`; do
        sed -i '$d' $turfpath
    done

    # If $nbuf is 0, no need to append the buffer.
    if [[ "$nbuf" != "0" ]]; then echo "$linebuf" >> $turfpath; fi
}

case "$#" in
    "0")    # List tags.
        ls_tags
        ;;
    "1")    # List or change cwd.
        case "$1" in
            "-h" | "--help")
                show_header
                show_usage
                ;;
            "ls")
                ls_tags
                ;;
            *)
                _path="$(get_tag "$1" -p)"
                if [[ "$_path" != "0" ]]; then cd "$_path";
                # Sourcing the file should not call exit. Just simply return
                # some error code.
                else return 1; fi
                ;;
        esac
        ;;
    "2")    # Remove a certain tag.
        if [[ "$1" != "rm" ]]; then show_usage; exit 1; fi

        tag_nth=$(get_tag "$2")
        if [[ "$tag_nth" != "0" ]]; then delete_tag $tag_nth;
        else exit 1; fi
        ;;
    "3")    # Add a folder tag.
        if [[ "$1" != "add" ]]; then show_usage; exit 1; fi

        _tag="$2"
        _path="$3"

        if [[ -f "$_path" ]]; then
            echo "warning: $_path a file, path added instead"
        fi

        tag_nth=$(get_tag "$_tag")
        if [[ "$tag_nth" != "0" ]]; then
            echo -n "$_tag already exists, replace it? [Y/n] "
            read to_replace
            case "$to_replace" in
                "Y" | "y" | "")
                    delete_tag $tag_nth
                    ;;
                *) exit 1 ;;
            esac
        fi

        abspath=$(cd $_path && pwd)
        echo "# $_tag $abspath" >> $turfpath
        ;;
    *)
        show_usage
        exit 1
        ;;
esac
